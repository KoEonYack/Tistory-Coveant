# Lock, DeadLock, Race Condition

## 파이썬 코드로 보는 Lock, DeadLock, Race Condition

<br />
<img src="./img/deadlock.png?raw=true" align="center" style="display: block; margin: 0px auto; display: block; height: auto; border:1px solid #eaeaea; padding: 0px;" width="" >
<br />
<br />



<br />
<br />

## 문제상황

<br />
<img src="./img/bank.png?raw=true" align="center" style="display: block; margin: 0px auto; display: block; height: auto; border:1px solid #eaeaea; padding: 0px;" width="70%" >
<br />

라이언, 무지, 어파치가 카카오뱅크에서 계좌 하나 만들고 각각 1000원씩 입금하려고 합니다. 라이언, 무지, 어파치가 동시에 입금한다고 할때 입금 코드를 통해서 어떤 문제가 발생할 수 있을지 살펴보겠습니다.

<br />
<br />

### 문제상황 코드

```python
import logging
from concurrent.futures import ThreadPoolExecutor
import time

class KakaoBank:
    # 공유 변수(value)
    def __init__(self):
        self.money = 0

    def deposit_1000won(self, user_name):
        print("Thread {}: 입금 시작합니다.".format(user_name))

        local_data = self.money
        local_data += 1000
        time.sleep(0.1)
        self.money = local_data
        
        print("Thread {}: 입금 종료합니다.".format(user_name))


if __name__ == "__main__":
    bank = KakaoBank()

    print("카카오뱅크 계좌를 생성하였습니다. 현재 잔액: {}원".format(bank.money))

    with ThreadPoolExecutor(max_workers=2) as executor:
        for user_name in ['라이언', '무지', '어파치']:
            executor.submit(bank.deposit_1000won, user_name)

    print("카카오뱅크 계좌 현재 잔액: {}원".format(bank.money))
```


```text
21:02:45: 카카오뱅크 계좌를 생성하였습니다. 현재 잔액: 0원
21:02:45: [Thread 라이언] 입금 시작합니다.
21:02:45: [Thread 무지] 입금 시작합니다.
21:02:45: [Thread 라이언] 입금 종료합니다.
21:02:45: [Thread 어파치] 입금 시작합니다.
21:02:45: [Thread 무지] 입금 종료합니다.
21:02:45: [Thread 어파치] 입금 종료합니다.
21:02:45: 카카오뱅크 계좌 현재 잔액: 2000원
```
라이언 무지 어파치가 1000원씩 입금하였기에 3000원이 나와야합니다. 그런데 2000원 나옵니다. 실제 이렇게 됬다면 카카오뱅크는 보상해주고 망했을것입니다. 어떻게 된 상황일까요?

- `for user_name in ['라이언', '무지', '어파치']:` 를 통해서 라이언, 무지, 어파치 순으로 `deposit_1000won` 메서드를 통해서 1000원을 계좌에 입금할 것입니다.
- `deposit_1000won` 메서드는 멀티쓰레드로 동작합니다. 거의 동시에 라이언, 무지, 어파치가 `deposit_1000won` 메서드를 실행할 것입니다.
- 1000원을 입금하고 `self.money`에 저장하기 전에 다른 누군가 `self.money`에 저장하


## Lock을 이용한 해결

### Lock을 이용한 해결 코드

```python
import logging
from concurrent.futures import ThreadPoolExecutor
import time
import threading

class KakaoBank:
    # 공유 변수(value)
    def __init__(self):
        self.money = 0
        self._lock = threading.Lock()

    # 변수 업데이트 함수
    # 스택 영역에 저장 - 자기 자신의 영역
    def deposit_1000won(self, user_name):
        print("Thread {}: 입금 시작합니다.".format(user_name))

        self._lock.acquire() # Lock 획득
    
        local_copy = self.money
        local_copy += 1000
        time.sleep(0.1)
        self.money = local_copy
        
        self._lock.release() # Lock 반환
        
        print("Thread {}: 입금 종료합니다.".format(user_name))


if __name__ == "__main__":
    bank = KakaoBank()

    print("카카오뱅크 계좌를 생성하였습니다. 현재 잔액: {}원".format(bank.money))

    with ThreadPoolExecutor(max_workers=2) as executor:
        for user_name in ['라이언', '무지', '어파치']:
            executor.submit(bank.deposit_1000won, user_name)

    print("카카오뱅크 계좌 현재 잔액: {}원".format(bank.money))
```

```text
카카오뱅크 계좌를 생성하였습니다. 현재 잔액: 0원
Thread 라이언: 입금 시작합니다.
Thread 무지: 입금 시작합니다.
Thread 라이언: 입금 종료합니다.
Thread 어파치: 입금 시작합니다.
Thread 무지: 입금 종료합니다.
Thread 어파치: 입금 종료합니다.
카카오뱅크 계좌 현재 잔액: 3000원
```


## 다른 방법으로 

```python
def deposit_1000won(self, user_name):
    print("Thread {}: 입금 시작합니다.".format(user_name))

    with self._lock:
        local_copy = self.money
        local_copy += 1000
        time.sleep(0.1)
        self.money = local_copy
    
    print("Thread {}: 입금 종료합니다.".format(user_name))
```